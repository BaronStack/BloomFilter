//
// Created by zhanghuigui on 2021/3/17.
//

#include "bloomfilter.h"

// CreateFilter:根据输入的key 批量构建bloom filter
// 参数1： keys, 输入的需要构造成bloomfilter的string列表
// 参数2： n，输入的元素个数
// 参数3： dst 最终的bloomfilter结果
//
// 这里的构造逻辑是通过双hash算法实现的，
// 针对输入的string 先生成一个uint32_t 的hash值
// 再针对其中的num_probe_个bit位进行置1
void BloomFilter::CreateFilter(std::string* keys,int n, std::string *dst ) {
	size_t bits = n* bits_per_key_;

	if(bits < 64) {
		bits = 64;
	}

	size_t bytes = (bits + 7) / 8;
	bits = bytes * 8;

	const size_t init_size = dst->size();
	dst->resize(init_size + bytes, 0);
	dst->push_back(static_cast<char>(num_probe_));  // Remember # of probes
	char* array = &(*dst)[init_size];
	// Use double-hashing to generate a sequence of hash values.
	// 这里使用双hash算法来生成hash值
	// See analysis in [Kirsch,Mitzenmacher 2006].
	for(size_t i = 0;i < static_cast<size_t>(n); i++) {
		uint32_t h = hash_func_(keys[i]);
		const uint32_t delta = (h >> 17) | (h << 15);
		for (size_t j = 0; j < num_probe_; j++) {
			const uint32_t bitpos = h % bits;
			array[bitpos/8] |= (1 << (bitpos % 8)); // 将bitpos位置置为1
			h += delta;
		}
	}
}

// 检查输入的key 是否存在于构造的bloom filter 之中
bool BloomFilter::KeyMayMatch(std::string key, std::string& bloom_filter){
	const size_t len = bloom_filter.size();
	if (len < 2) return false;

	const char* array = bloom_filter.c_str();
	const size_t bits = (len - 1) * 8;

	// Use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	const size_t k = array[len-1];
	if (k > 30) {
		// Reserved for potentially new encodings for short bloom filters.
		// Consider it a match.
		return true;
	}

	uint32_t h = hash_func_(key);
	const uint32_t delta = (h >> 17) | (h << 15);
	for (size_t j = 0; j < k; j++) {
		const uint32_t bitpos = h % bits;
		if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
		h += delta;
	}
	return true;
}
